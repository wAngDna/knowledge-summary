### Vue2 响应式原理

响应式数据的最终目标就是`当对象本身或者对象属性发生变化时，执行一些函数`，最常见的就是执行 `render` 函数重新生成虚拟 `DOM` ， 然后与旧虚拟 `DOM` 比对后生成真实 `DOM` ，达到修改界面的目的。

在具体实现上，vue 用到了几个核心部件

1. Observer

`Observer` 的目标就是将一个`普通的对象转换成一个响应式对象`，`循环递归遍历对象`，把对象的`每个属性`通过 `Object.defineProperty` 转换为带有`getter` 和 `setter` 的属性，这样当访问或设置属性时，vue 就会有机会做一些别的事儿。

在生命周期中，这件事发生在 `breforeCreate` 之后，`created` 之前。

由于遍历时只能遍历当前对象的属性，后续这个对象新增的属性无法记监测到的，因此 Vue 提供了`$set` 和`$delete` 方法来主动将新增的属性变成响应式的。

对于数组，vue 会更改他的隐式原型方法，之所以这样做，是因为 vue 需要监听那些可能改变数组内容的方法。

2. Dep

Dep 解决的问题就是`读取属性`时要做什么，`属性变化`时要做什么，这俩个问题就是 `Dep` 去做的。

Vue 会为响应式对象的每个属性、对象本身、数组本身创建一个 `Dep` 实例，每个 `Dep` 实例都有能力做俩件事：

- 记录依赖：是谁在用我

- 派发更新：我变了，通知所有用到我的人改进行更新了

3. Watcher

这里又出现了问题，就是 `Dep` 如何知道是谁在用我？要解决这个问题，就需要 `Watcher`，当某个函数执行的过程中，用到了`响应式数据`，`响应式数据`是无法知道哪个函数在用自己。

因此 vue 想了一个办法，我们不要直接执行函数，而是把函数交给一个叫做 `Watcher` 的东西去执行，`Watcher` 是一个对象，每个这样的函数执行时都会创建一个 `Watcher`，通过 `Watcher` 去执行。

`Watcher` 会设置一个全局变量，让全局变量记录当前负责执行的 `Watcher` 等于自己，然后再去执行函数，在函数的执行过程中，如果发生了依赖记录，那么 `Dep` 就会把这个全局变量记录下来，表示有一个 `Watcher` 用到了我这个属性，这样 `Dep` 进行派发更新时，就会通知之前记录的所有 `Watcher`。

每个组件至少对应一个 `Watcher`， 该 `Watcher` 中记录了该组件的 `render` 函数。
`Watcher` 首先会把 `render` 函数运行一次以收集依赖，于是那些在 `render` 中用到的`响应式数据`就会记录这个 `Watcher`。
当数据变化时，`Dep` 就会通知该 `Watcher`，而 `Watcher` 将重新运行 `render` 函数，从而让界面更新同时重新记录当前依赖。

4. Scheduler(调度器)

`Dep` 通知 `Watcher` 之后，如果 `Watcher` 执行，重新运行对应的函数，就可能导致函数频繁运行，从而导致效率低下。
例如，一个对象有四个属性，一个函数用到了这四个属性，那么这四个属性都会记录依赖，于是函数就会执行四次，这样显然是不行的，因此，`Watcher` 收到派发更新的通知后，实际上不是`立即执行对应函数`，而是把自己交给一个叫调度器的东西。
调度器维护一个队列，该队列同一个 `Watcher` 仅会存在一次，队列中的 `Watcher` 不是立即执行，它会通过一个叫做 `nextTick` 的工具方法，把这些需要执行的 `Watcher` 放入到事件循环的微队列中，`nextTick` 的具体做法是通过 `Promise` 完成的，也就是说，当`响应式数据`变化时，`render` 函数是`异步执行`的，并且是在`微队列`中的。
